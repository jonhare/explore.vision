{"name":"Image transforms","code":"var count = 0;\n\nfunction process(input, output) {\n    var rotation = count / 30;\n    var scale = Math.sin(rotation) + 2;\n    count++;\n    \n\tvar tf = rotationScaleMatrixAboutPoint(rotation, scale, input.width/2, input.height/2);\n\tvar itf = matrixInverse3x3(tf);\n\n    var x, y, xt, yt;\n    var v = [0,0,1];\n    var tfv = [0,0,0];\n    for (y=0; y<output.height; y++) {\n    \tv[1] = y;\n        for (x=0; x<output.width; x++) {\n        \tv[0] = x;\n        \tmatrixDotVector3x3(tfv, itf, v);\n\n        \txt = tfv[0]/tfv[2];\n        \tyt = tfv[1]/tfv[2];\n\n            assignPixelInterp(input, output, x, y, xt, yt);\n        }\n    }\n}\n\nfunction rotationScaleMatrixAboutPoint(rot, scale, tx, ty) {\n\treturn \tmatrixMultiply3x3(\n\t\t\t\tmatrixMultiply3x3(\n\t\t\t\t\tmatrixMultiply3x3(\n\t\t\t\t\t\tmatrixMultiply3x3(\n\t\t\t\t\t\t\tidentityMatrix3x3(), \n\t\t\t\t\t\t\ttranslateMatrix3x3(tx, ty)\n\t\t\t\t\t\t),\n\t\t\t\t\t\trotationMatrix3x3(rot)\n\t\t\t\t\t),\n\t\t\t\t\tscaleMatrix3x3(scale)\n\t\t\t\t),\n\t\t\t\ttranslateMatrix3x3(-tx, -ty)\n\t\t\t);\n}\n\nfunction translateMatrix3x3(x, y) {\n\treturn [[1,0,x],[0,1,y],[0,0,1]];\n}\n\nfunction scaleMatrix3x3(sc) {\n\treturn [[sc,0,0],[0,sc,0],[0,0,1]];\n}\n\nfunction rotationMatrix3x3(rot) {\n\treturn [[Math.cos(rot),-Math.sin(rot),0],[Math.sin(rot),Math.cos(rot),0],[0,0,1]];\n}\n\nfunction zeroMatrix3x3() {\n\treturn [[0,0,0],[0,0,0],[0,0,0]];\n}\n\nfunction identityMatrix3x3() {\n\treturn [[1,0,0],[0,1,0],[0,0,1]];\n}\n\nfunction matrixDotVector3x3(result,m,v) {\n\tresult[0] = m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2];\n\tresult[1] = m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2];\n\tresult[2] = m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2];\n}\n\nfunction matrixMultiply3x3(a,b) {\n\tvar c = zeroMatrix3x3();\n\tc[0][0] = a[0][0]*b[0][0]+a[0][1]*b[1][0]+a[0][2]*b[2][0];\n\tc[0][1] = a[0][0]*b[0][1]+a[0][1]*b[1][1]+a[0][2]*b[2][1];\n\tc[0][2] = a[0][0]*b[0][2]+a[0][1]*b[1][2]+a[0][2]*b[2][2];\n\t                         \n\tc[1][0] = a[1][0]*b[0][0]+a[1][1]*b[1][0]+a[1][2]*b[2][0];\n\tc[1][1] = a[1][0]*b[0][1]+a[1][1]*b[1][1]+a[1][2]*b[2][1];\n\tc[1][2] = a[1][0]*b[0][2]+a[1][1]*b[1][2]+a[1][2]*b[2][2];\n\t                         \n\tc[2][0] = a[2][0]*b[0][0]+a[2][1]*b[1][0]+a[2][2]*b[2][0];\n\tc[2][1] = a[2][0]*b[0][1]+a[2][1]*b[1][1]+a[2][2]*b[2][1];\n\tc[2][2] = a[2][0]*b[0][2]+a[2][1]*b[1][2]+a[2][2]*b[2][2];\n\treturn c;\n}\n\nfunction matrixInverse3x3(m) {\n\t//determinant:\n\tvar det = m[0][0] * (m[1][1]*m[2][2] - m[1][2] * m[2][1]);\n\tdet -= m[0][1] * (m[1][0]*m[2][2] - m[1][2] * m[2][0]);\n\tdet += m[0][2] * (m[1][0]*m[2][1] - m[1][1] * m[2][0]);\n\n\t//scale\n\tvar s = 1.0 / (det);\n\n\tvar a = zeroMatrix3x3();\n\ta[0][0] = (s) * (m[1][1] * m[2][2] - m[1][2] * m[2][1]); \n\ta[1][0] = (s) * (m[1][2] * m[2][0] - m[1][0] * m[2][2]); \n\ta[2][0] = (s) * (m[1][0] * m[2][1] - m[1][1] * m[2][0]); \n\t                            \n\ta[0][1] = (s) * (m[0][2] * m[2][1] - m[0][1] * m[2][2]); \n\ta[1][1] = (s) * (m[0][0] * m[2][2] - m[0][2] * m[2][0]); \n\ta[2][1] = (s) * (m[0][1] * m[2][0] - m[0][0] * m[2][1]); \n\t                            \n\ta[0][2] = (s) * (m[0][1] * m[1][2] - m[0][2] * m[1][1]); \n\ta[1][2] = (s) * (m[0][2] * m[1][0] - m[0][0] * m[1][2]); \n\ta[2][2] = (s) * (m[0][0] * m[1][1] - m[0][1] * m[1][0]); \n\n\treturn a;\n}\n\nfunction bilerp(output, x, y, f00, f01, f10, f11) {\n\toutput.r = f00.r * (1.0 - x) * (1.0 - y) + f10.r * x * (1.0 - y) + f01.r * (1.0 - x) * y + f11.r * x * y;\n\toutput.g = f00.g * (1.0 - x) * (1.0 - y) + f10.g * x * (1.0 - y) + f01.g * (1.0 - x) * y + f11.g * x * y;\n\toutput.b = f00.b * (1.0 - x) * (1.0 - y) + f10.b * x * (1.0 - y) + f01.b * (1.0 - x) * y + f11.b * x * y;\n}\n\n\nfunction assignPixelInterp(input, output, _x, _y, x, y)\n{\n\tvar x0 = Math.floor(x);\n\tvar x1 = x0 + 1;\n\tvar y0 = Math.floor(y);\n\tvar y1 = y0 + 1;\n\n\tvar tx0, tx1, ty0, ty1;\n\ttx0 = ty0 = tx1 = ty1 = true;\n\tif (x0 < 0)\n\t\ttx0 = false;\n\tif (x0 >= input.width)\n\t\ttx0 = false;\n\tif (y0 < 0)\n\t\tty0 = false;\n\tif (y0 >= input.height)\n\t\tty0 = false;\n\n\tif (x1 < 0)\n\t\ttx1 = false;\n\tif (x1 >= input.width)\n\t\ttx1 = false;\n\tif (y1 < 0)\n\t\tty1 = false;\n\tif (y1 >= input.height)\n\t\tty1 = false;\n\n\tvar f00 = (ty0 && tx0 ? input[y0][x0] : 0);\n\tvar f01 = (ty1 && tx0 ? input[y1][x0] : 0);\n\tvar f10 = (ty0 && tx1 ? input[y0][x1] : 0);\n\tvar f11 = (ty1 && tx1 ? input[y1][x1] : 0);\n\n\tvar dx = x - x0;\n\tvar dy = y - y0;\n\tif (dx < 0)\n\t\tdx = 1 + dx;\n\tif (dy < 0)\n\t\tdy = 1 + dy;\n\n\tbilerp(output[_y][_x], dx, dy, f00, f01, f10, f11);\n}\n"}
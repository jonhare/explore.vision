{"name":"Harris Corner Detector","code":"var harris;\n\nfunction process(input, output) {\n    if (!harris) harris = new Harris(input.width, input.height);\n\n    harris.computeResponse(input);\n    //harris.drawResponse(output);\n    harris.drawPoints(input, output, 0.0000001);\n}\n\nfunction Harris(width, height) {\n\tthis.detectionScale = (0.6 * 1) * (0.6 * 1);\n\tthis.integrationScale = 1 * 1;\n\tthis.eigenRatio = 0.01;\n\n\tthis.detectionGauss = createGaussian1d(this.detectionScale);\n\tthis.integrationGauss = createGaussian1d(this.integrationScale);\n\n\tthis.original \t = newArray2d(width, height);\t\n\tthis.l \t\t\t = newArray2d(width, height);\n\tthis.lx \t\t = newArray2d(width, height);\n\tthis.ly \t\t = newArray2d(width, height);\n\tthis.lxmx \t\t = newArray2d(width, height);\n\tthis.lymy \t\t = newArray2d(width, height);\n\tthis.lxmy \t\t = newArray2d(width, height);\n\tthis.lxmxblur \t = newArray2d(width, height);\n\tthis.lymyblur \t = newArray2d(width, height);\n\tthis.lxmyblur \t = newArray2d(width, height);\n\tthis.responseMap = newArray2d(width, height);\n\n\tthis.DX = [-0.5 * this.detectionScale, 0, 0.5 * this.detectionScale];\n\tthis.DY = [-0.5 * this.detectionScale, 0, 0.5 * this.detectionScale];\n\n\tthis.computeResponse = function(image) {\n\t\tvar x, y, width = image.width, height = image.height;\n\t\tfor (y=0; y<height; y++) {\n\t\t\tfor (x=0; x<width; x++) {\n\t\t\t\tthis.original[y][x] = (image[y][x].r + image[y][x].g + image[y][x].b) * 0.3333333333;\n\t\t\t}\n\t\t}\n\n\t\tconvolve(this.original, this.l, this.detectionGauss);\n\t\tconvolveHorizontal(this.l, this.lx, this.DX);\n\t\tconvolveVertical(this.l, this.ly, this.DY);\n\n\t\tfor (y=0; y<height; y++) {\n\t\t\tfor (x=0; x<width; x++) {\n\t\t\t\tthis.lxmx[y][x] = this.lx[y][x] * this.lx[y][x];\n\t\t\t\tthis.lymy[y][x] = this.ly[y][x] * this.ly[y][x];\n\t\t\t\tthis.lxmy[y][x] = this.lx[y][x] * this.ly[y][x];\n\t\t\t}\n\t\t}\n\n\t\tconvolve(this.lxmx, this.lxmxblur, this.integrationGauss);\n\t\tconvolve(this.lymy, this.lymyblur, this.integrationGauss);\n\t\tconvolve(this.lxmy, this.lxmyblur, this.integrationGauss);\n\n\t\tthis.minResponse = 10000;\n\t\tthis.maxResponse = -10000;\n\t\tfor (y=10; y<height-10; y++) {\n\t\t\tfor (x=10; x<width-10; x++) {\n\t\t\t\tvar det = this.lxmxblur[y][x] * this.lymyblur[y][x] - this.lxmyblur[y][x] * this.lxmyblur[y][x];\n\t\t\t\tvar trace = this.lxmxblur[y][x] + this.lymyblur[y][x];\n\t\t\t\tvar traceSq = trace * trace;\n\t\t\n\t\t\t\tthis.responseMap[y][x] = det - traceSq * this.eigenRatio;\n\t\t\t\tthis.maxResponse = Math.max(this.maxResponse, this.responseMap[y][x]);\n\t\t\t\tthis.minResponse = Math.min(this.minResponse, this.responseMap[y][x]);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.drawResponse = function(output) {\n\t\tvar width = output.width, height = output.height;\n\n\t\tfor (y=0; y<height; y++) {\n\t\t\tfor (x=0; x<width; x++) {\n\t\t\t\tvar val = (this.responseMap[y][x] + this.minResponse) / (this.maxResponse - this.minResponse);\n\t\t\t\toutput[y][x].r = val;\n\t\t\t\toutput[y][x].g = val;\n\t\t\t\toutput[y][x].b = val;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.getPoints = function(threshold) {\n\t\tvar x, y, borderSkip=11;\n\t\tvar maxima = [];\n\t\tfor (y = borderSkip; y < this.responseMap.length - borderSkip; y++) {\n\t\t\tfor (x = borderSkip; x < this.responseMap[0].length - borderSkip; x++) {\n\t\t\t\tvar curr = this.responseMap[y][x];\n\t\t\t\tif (curr > threshold\n\t\t\t\t\t\t&& curr > this.responseMap[y - 1][x - 1]\n\t\t\t\t\t\t&& curr >= this.responseMap[y - 1][x]\n\t\t\t\t\t\t&& curr >= this.responseMap[y - 1][x + 1]\n\t\t\t\t\t\t&& curr >= this.responseMap[y][x - 1]\n\t\t\t\t\t\t&& curr >= this.responseMap[y][x + 1]\n\t\t\t\t\t\t&& curr >= this.responseMap[y + 1][x - 1]\n\t\t\t\t\t\t&& curr >= this.responseMap[y + 1][x]\n\t\t\t\t\t\t&& curr >= this.responseMap[y + 1][x + 1])\n\t\t\t\t{\n\t\t\t\t\tmaxima.push({\"x\":x, \"y\":y, \"val\": curr});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog(\"Detected \" + maxima.length + \" points.\");\n\t\treturn maxima;\n\t};\n\n\tthis.drawPoints = function(image, output, threshold) {\n\t\tvar x, y, width = image.width, height = image.height;\n\t\tfor (y=0; y<height; y++) {\n\t\t\tfor (x=0; x<width; x++) {\n\t\t\t\toutput[y][x].r = image[y][x].r;\n\t\t\t\toutput[y][x].g = image[y][x].g;\n\t\t\t\toutput[y][x].b = image[y][x].b;\n\t\t\t}\n\t\t}\n\n\t\tvar i, points = this.getPoints(threshold);\n\t\tfor (i=0; i<points.length; i++) {\n\t\t\tfor (y=points[i].y-1; y<=points[i].y+1; y++) {\n\t\t\t\tfor (x=points[i].x-1; x<=points[i].x+1; x++) {\n\t\t\t\t\toutput[y][x].r = 1;\n\t\t\t\t\toutput[y][x].g = 0;\n\t\t\t\t\toutput[y][x].b = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction newArray2d(width, height) {\n\tvar arr = [];\n\n\tfor (var y=0; y<height; y++) {\n\t\tarr.push([]);\n\t\tfor (var x=0; x<width; x++) {\n\t\t\tarr[y].push(0);\n\t\t}\n\t}\n\treturn arr;\n}\n\nfunction createGaussian1d(sigma) {\n\tif (sigma === 0)\n\t\treturn [1];\n\n\tvar trunc = 4;\n\tvar ksize = Math.floor(2 * sigma * trunc + 1);\n\tif (ksize % 2 === 0)\n\t\t\tksize++;\n\t\n\tvar kernel = new Array(ksize);\n\n\tvar i, sum = 0.0;\n\tfor (i = 0; i < ksize; i++) {\n\t\tvar x = i - Math.floor(ksize / 2);\n\t\tkernel[i] = Math.exp(-x * x / (2.0 * sigma * sigma));\n\t\tsum += kernel[i];\n\t}\n\n\tfor (i = 0; i < ksize; i++) {\n\t\tkernel[i] /= sum;\n\t}\n\n\treturn kernel;\n}\n\nfunction convolve(inp, out, kern) {\n    convolveHorizontal(inp, out, kern);\n\tconvolveVertical(out, out, kern);\n}\n\n/**\n * Convolve the image in the horizontal direction with the kernel. Edge\n * effects are handled by duplicating the edge pixels.\n * \n * @param image\n *            the image to convolve.\n * @param output\n *            the output image (can be same as input).\n * @param kernel\n *            the convolution kernel.\n */\nfunction convolveHorizontal(image, output, kernel) {\n\tvar halfsize = Math.floor(kernel.length / 2);\n\tvar buffer = new Array(image[0].length + kernel.length);\n\tvar r, c, i, j, jj;\n\tfor (r = 0; r < image.length; r++) {\n\t\tfor (i = 0; i < halfsize; i++)\n\t\t\tbuffer[i] = image[r][0];\n\t\tfor (i = 0; i < image[0].length; i++)\n\t\t\tbuffer[halfsize + i] = image[r][i];\n\t\tfor (i = 0; i < halfsize; i++)\n\t\t\tbuffer[halfsize + image[0].length + i] = image[r][image[0].length - 1];\n\n\t\tvar l = buffer.length - kernel.length;\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tvar sum = 0.0;\n\n\t\t\tfor (j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)\n\t\t\t\tsum += buffer[i + j] * kernel[jj];\n\n\t\t\tbuffer[i] = sum;\n\t\t}\n\t\t\n\t\tfor (c = 0; c < image[0].length; c++)\n\t\t\toutput[r][c] = buffer[c];\n\t}\n}\n\n/**\n * Convolve the image in the vertical direction with the kernel. Edge\n * effects are handled by duplicating the edge pixels.\n * \n * @param image\n *            the image to convolve.\n * @param output\n *            the output image (can be same as input).\n * @param kernel\n *            the convolution kernel.\n */\nfunction convolveVertical(image, output, kernel) {\n\tvar halfsize = Math.floor(kernel.length / 2);\n\n\tvar buffer = new Array(image.length + kernel.length);\n\n\tvar r, c, i, j, jj;\n\tfor (c = 0; c < image[0].length; c++) {\n\t\tfor (i = 0; i < halfsize; i++)\n\t\t\tbuffer[i] = image[0][c];\n\t\tfor (i = 0; i < image.length; i++)\n\t\t\tbuffer[halfsize + i] = image[i][c];\n\t\tfor (i = 0; i < halfsize; i++)\n\t\t\tbuffer[halfsize + image.length + i] = image[image.length - 1][c];\n\n\t\tvar l = buffer.length - kernel.length;\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tvar sum = 0.0;\n\n\t\t\tfor (j = 0, jj = kernel.length - 1; j < kernel.length; j++, jj--)\n\t\t\t\tsum += buffer[i + j] * kernel[jj];\n\n\t\t\tbuffer[i] = sum;\n\t\t}\n\n\t\tfor (r = 0; r < image.length; r++)\n\t\t\toutput[r][c] = buffer[r];\n\t}\n}\n"}